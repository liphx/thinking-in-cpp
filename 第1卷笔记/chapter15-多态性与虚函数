函数调用捆绑
早捆绑 捆绑在程序运行之前(由编译器和连接器)完成
晚捆绑 捆绑发生在运行时

虚函数
virtual 仅需要在声明的时候使用，定义时不需要
如果一个函数在基类中是虚函数，那么在所有的派生类中都是虚函数
在派生类中虚函数重定义称为重写

1-15-virtual.cpp

VTABLE
在每个带有虚函数的类中，编译器放置一个指针，vpointer(VPTR),指向这个对象的VTABLE
当通过基类指针做虚函数调用时，编译器静态地插入能取得这个VPTR并在VTABLE表中查找函数地址的代码
这样就能调用正确的函数并引起晚捆绑的发生

1-15-vptr.cpp

抽象基类和纯虚函数
virtual void f() = 0;
纯虚函数禁止对抽象类的函数以传值方式调用
可以对纯虚函数提供定义

在继承中添加虚函数
编译器会防止调用只存在与派生类中的函数，如果确认是哪一类子类，可以强制转换这个指针

如果一个对象进行向上类型转换，而不使用地址或引用，这个对象会被“切片”
纯虚函数的一个作用是防止对象切片，因为不能创建抽象基类的对象，编译器将产生错误

在基类中的虚函数，如果要在派生类中重写，不允许改变返回值类型（非虚函数可以），基类中其他重载的函数同样会被隐藏
一个特例，如果返回值是基类指针或引用，重写的函数可以返回派生类指针或引用

当创建一个包含有虚函数的对象时，必须初始化它的VPTR以指向相应的VTABLE.这必须在虚函数进行任何调用前完成
设置VPTR是构造函数的工作

虚机制在构造函数中不工作，只会调用虚函数的本地版本

构造函数是不能为虚函数的，但析构函数常常必须是虚的

C++中允许纯虚析构函数，但必须为纯虚析构函数提供一个函数体

在析构函数中，只有成员函数的本地版本会被调用，虚机制被忽略
构造函数也是如此，但构造函数是因为类型信息还不可用，析构函数中信息虽然存在，但不可靠

单根继承(基于对象的继承) C++不强制使用
当创建一个类时，都会直接或间接地从一个公共基类中继承它

多重指派
一个单一虚函数调用引起了第二个虚函数调用

dynamic_cast
向下类型转换时，仅当类型转换是正确的并且成功时返回指向所需类型的指针，否则返回0
1-15-dynamic-cast.cpp